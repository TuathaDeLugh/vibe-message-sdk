#!/usr/bin/env node

const fs = require('fs');
const path = require('path');

const args = process.argv.slice(2);
const command = args[0];

if (command !== 'init') {
  console.log('Usage: npx vibe-message init');
  process.exit(1);
}

console.log('üöÄ Initializing Vibe Message Service Worker...');

// Service worker template
const swContent = `// Service Worker for Vibe Message Push Notifications
// Auto-generated by vibe-message SDK

self.addEventListener("push", (event) => {
  const data = event.data ? event.data.json() : {};

  // Handle silent notifications (no UI, just data sync)
  if (data.silent) {
    event.waitUntil(
      self.clients
        .matchAll({ includeUncontrolled: true, type: "window" })
        .then((clients) => {
          // Send silent message to all clients
          clients.forEach((client) => {
            client.postMessage({
              type: "SILENT_MESSAGE",
              data: data.data || {},
            });
          });
        })
    );
    return;
  }

  // Check if any client window is focused (app is visible)
  event.waitUntil(
    self.clients
      .matchAll({ includeUncontrolled: true, type: "window" })
      .then((clients) => {
        const focusedClient = clients.find((client) => client.visibilityState === "visible" || client.focused);

        if (focusedClient) {
          // App is visible - send message to foreground
          focusedClient.postMessage({
            type: "FOREGROUND_MESSAGE",
            payload: {
              title: data.title || "Notification",
              body: data.body || "",
              icon: data.icon || "/icon.png",
              data: data.data || {},
            }
          });
        } else {
          // App is not visible - show push notification
          const title = data.title || "Notification";
          const options = {
            body: data.body || "",
            icon: data.icon || "/icon.png",
            image: data.image,
            badge: "/badge.png",
            data: {
              click_action: data.click_action || "/",
              ...data.data,
            },
            requireInteraction: false,
            tag: "fcm-clone-notification",
          };

          return self.registration.showNotification(title, options);
        }
      })
  );
});

self.addEventListener("notificationclick", (event) => {
  event.notification.close();

  const urlToOpen = event.notification.data?.click_action || "/";

  event.waitUntil(
    self.clients
      .matchAll({ type: "window", includeUncontrolled: true })
      .then((clientList) => {
        // Check if there's already a window open with this URL
        for (const client of clientList) {
          if (client.url === urlToOpen && "focus" in client) {
            // Send background message callback
            client.postMessage({
              type: "BACKGROUND_MESSAGE",
              payload: event.notification.data,
            });
            return client.focus();
          }
        }

        // If not, open a new window
        if (self.clients.openWindow) {
          return self.clients.openWindow(urlToOpen).then((client) => {
            if (client) {
              // Send background message to new window
              client.postMessage({
                type: "BACKGROUND_MESSAGE",
                payload: event.notification.data,
              });
            }
          });
        }
      })
  );
});

self.addEventListener("activate", (event) => {
  event.waitUntil(self.clients.claim());
});

self.addEventListener("install", (event) => {
  self.skipWaiting();
});
`;

// Common public directories in modern web frameworks
const possibleDirs = ['public', 'out', 'dist', 'static', '.'];
let targetDir = '.';

for (const dir of possibleDirs) {
  const fullPath = path.join(process.cwd(), dir);
  if (fs.existsSync(fullPath) && fs.statSync(fullPath).isDirectory()) {
    // We prefer 'public' if it exists, otherwise fallback
    if (dir === 'public') {
      targetDir = dir;
      break;
    }
    // If we haven't found public, just keep the first valid one
    if (targetDir === '.') {
      targetDir = dir;
    }
  }
}

const targetPath = path.join(process.cwd(), targetDir, 'push-sw.js');

try {
  fs.writeFileSync(targetPath, swContent);
  console.log(`‚úÖ Successfully created Service Worker at: ${targetPath}`);
  console.log('You are all set to receive push notifications!');
} catch (error) {
  console.error('‚ùå Failed to create Service Worker:', error.message);
  process.exit(1);
}
